Описание приложения
----------
- Распределенное приложение пересылает сообщение соседним нодам.
- При получении сообщения в консоль выводится количество сообщений полученных текущей нодой за последнюю секунду.
- Можно изменить количество сообщений пересылаемых в секунду сразу на всех нодах одновременно
- Можно добавлять и удалять работающие ноды


Приложение выполняет **две** роли:

- sender
- controller

sender
-------------
Функции

 - Отправка сообщений с одной ноды на другую.
controller
-------------
Функции

 - Динамическое добавление ноды в распределенное приложение.
 - Динамическое удаление ноды из распределенное приложение.
 - Изменение количество сообщений, отправляемых в секунду.

Требования к окружению
----------
```
>sbt sbtVersion
>0.13.12
```

```
>scala -version
>Scala code runner version 2.11.8
```

```
>java -version
>java version "1.8.0_111"
```

>  **Примечание:** Скорее всего работает и с более новым окружением, но я не проверял

Использование
-------------
Первым делом
```
>git clone pathToRepo
>cd test-akka
```
sender
-------------
sender занимается отправкой сообщений на соседние ноды.
Для запуска и работы необходимо:

 - указать ноде приложения, какие ноды является для нее соседними,
 - информировать ноду о том, на каком хосте и порту она работает

Для этого создатим фай `senderNode00Conf` (имя файла не захаркодено, можно и другое). В файл запишем
```
localhost address0:port0
sendTo address3:port3
sendTo address4:port4
```
Напротив параметра `localhost` следует указать адрес и порт машины, на которой будет запущена нода приложения. 
Напротив параметров `receiveFrom` и `sendTo` указать адреса и порты машин, с которых сообщения будут приниматься и на которые будут отправляться данной нодой приложения. Таких параметров может быть несколько, т.е. можно определить несколько "соседних" машин.

>  **Некоторые замечания по оформлению файла конфигурации:**

>  - Пробелы между строк недопустимы.
>  - Между `localhost/receiveFrom/sendTo` и > `address:port` только один пробел.
>  - Порядок следования строк не важен.
>  -  `localhost` - обязательный параметр (далее будет сказано почему). `sendTo` и `receiveFrom` - опционально.
>  - К сожалению, это все захардкодено :(

После того, как файл создан, можно запустить ноду приложения.
```
>pwd
/home/iamuser/test-akka
>sbt "run-main org.remote.app.App --role=sender /path/to/senderNode01Conf"
```

Можно будет увидеть сообщения:
```
>Remote actor akka.tcp://messagingSystem@address3:port3/user/managerActor/address0:port0receiver is not available
>Remote actor akka.tcp://messagingSystem@address4:port4/user/managerActor/address0:port0receiver is not available
```
Как это понимать? Вот так:

При запуске приложения с такой конфигурацией нода будет пытаться слать сообщения другим нодам приложения, работающим на машинах и портах (`address3:port3`, `address4:port4`) как было указано в конфигурации выше.
На этих нодах должен работать актор, который будет принимать сообщения от ноды `address0:port0`, имя которого `address0:port0receiver`. Его, как видим, нет.

Значит, нужно запустить на соседних нодах `address3:port3` и `address4:port4` 
Создадим конфиг файлы `senderNode03Conf` и `senderNode04Conf`

`senderNode03Conf`
```
localhost address3:port3
receiveFrom address0:port0
```
`senderNode03Conf`
```
localhost address4:port4
receiveFrom address0:port0
```

И аналогично запускаем ноды приложения на этих машинах. Ошибка пропала, в консолях `address3`, `address4` видим примерный вывод.
```
1
1
0
1
...
```
Это количество полученных сообщений в секунду данным нодами.
Конечно же в одном файле можно задать и `sendTo`, и `receiveFrom`  параметры.

Можно на время выключить одну или несколько нод или добавить больше нод. Главное, чтобы у нод были совместимые конфигурации.

controller
-------------
Конфиг файл `controllerConf` для контроллера выглядит так:
```
localhost address0:port0
control address1:port1
control address2:port2
control address3:port3
```
Интуитивно понятно, что `localhost` отвечает за "местоположение" в сети текущей ноды. `control` - за контроль над `address*:port*` нодами.

Все ноды, над которыми берется контроль, должны работать конечно же. Если какая-то нода не работает, но указана в конфиге, то контроллер будет бесконечно ее ждать, пока не выключится или нода не заработает.

>  **Некоторые замечания по оформлению файла конфигурации:**

>  - Пробелы между строк недопустимы.
>  - Между `localhost/control` и  `address:port` только один пробел.
>  - Порядок следования строк не важен.
>  -  `localhost` - обязательный параметр (далее будет сказано почему). `control` - опционально.
>  - К сожалению, это все захардкодено :(

Запустим приложение
```
>pwd
/home/iamuser/test-akka
>sbt "run-main org.remote.app.App --role=controller /path/to/controllerConf"
```
По умолчанию ноды передают друг другу по 10 сообщений в секунду. Можно передавать больше. Для этого введем:
```
updateMessagesPerSecond 100
```

Дополнительное использование
-------------
Описанное использование достаточно сильно зависит от конфиг файлов. Ноду приложения нужно перезапускать каждый раз, когда конфигурация должна измениться. А если одна из нод завершилась `Ctrl + C`, тогда другая будет бесконечно ждать ее возвращения, пока сама не будет завершена.

Это неудобно. Лучше конечно же менять конфигурацию нод приложения через какой-то инструмент. Для этого есть ноды с ролью `controller`.

Рассмотрим простой пример.
Пусть в конфиг файлах, перечисленных выше, указаны только `localhost` параметры.

Запустим `controller` на `address0:port0` 
```
>pwd
home/iamuser/test-akka
>cat /path/to/controllerConf
address0:port0
>sbt "run-main org.remote.app.App --role=sender /path/to/controllerConf"
```

 и два `sender` 
 
```
>pwd
home/iamuser/test-akka
>cat /path/to/sender1Conf
address1:port1
>sbt "run-main org.remote.app.App --role=sender /path/to/sender1Conf"
```
На разных машинах
```
>pwd
home/iamuser/test-akka
>cat /path/to/sender2Conf
address2:port2
>sbt "run-main org.remote.app.App --role=sender /path/to/sender2Conf"
```

Начнем контроллировать обоих `sender`'ов. Попросим первого пересылать сообщения второму, а второго принимать их от первого. Затем всем контролируемым нодам скажем пересылать по 100 сообщений в секунду. 
(Все перечисленное дальше делаем в CLI `controller`'а)

```
>control address1:port1 start
>control address2:port2 start
>address2:port2 receiveFrom address1:port1 start
>address1:port1 sendTo address2:port2 start
>updateMessagesPerSecond 100
```

Сообщения пересылаются!
Теперь завершим работу.
```
>address1:port1 sendTo address2:port2 stop
>address2:port2 receiveFrom address1:port1 stop
>control address1:port1 stop
>control address2:port2 stop
```

Можно таким образом конфигурировать сколько угодно сложные соседские "отношения" внутри кластера между нодами.

Принцип работы
-------------
Это может быть полезно человеку, разбирающему данный код.
Если с ноды `a` на ноду `b` пересылается сообщение, то создается актор на `a` для отправки сообщения, а на `b` для его получения. Причем, созданные акторы отправляют и принимают сообщения только с одной ноды и только на одну ноду.
Назовем это "каналом связи".

То есть

Если будет добавлена нода `с` и с `а` на нее слать сообщения, то на `a` будет создан новый актор, который будет слать только на `с`. Аналогично, если на `b` получать сообщения еще и с `с`, то на `b` создается новый актор, принимающий сообщения только с `с` (и еще на `с` создается актор отправляющий только `b`)

Оценка производительности
-------------
Один актор (если он remote) принимает по сети 1 - 1.5 сообщений в секунду максимум. Я запускал 10 jvm машин, некоторые из них были в VirtualBox под линуксом, некоторые под видной локально. В такой конфигурации с таким принципом работы, можно получать 10К сообщений в секунду и больше на одной ноде.

Можно и больше получать, но для этого надо прицип работы поменять: использовать не по одному "каналу связи" (см. выше) а много.

Артур Южанин.